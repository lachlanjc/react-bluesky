# API Reference

### `Post`

```tsx
import { Post } from "bsky-react-post";
```

```tsx
<Post uri="1629307668568633344">
```

Fetches and renders the post. It accepts the following props:

- **uri** - `string`: the post URI. For example in `https://twitter.com/chibicode/status/1629307668568633344` the tweet ID is `1629307668568633344`. This is the only required prop.
- **apiUrl** - `string`: the API URL to fetch the post from when using the post client-side with SWR. Defaults to `https://react-tweet.vercel.app/api/tweet/:id`.
- **fallback** - `ReactNode`: The fallback component to render while the post is loading. Defaults to `TweetSkeleton`.
- **onError** - `(error?: any) => any`: The returned error will be sent to the `TweetNotFound` component.
- **components** - `TwitterComponents`: Components to replace the default tweet components. See the [custom tweet components](#custom-tweet-components) section for more details.
- **fetchOptions** - `RequestInit`: options to pass to [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch).

If the environment where `Post` is used does not support React Server Components then it will work with [SWR](https://swr.vercel.app/) instead and the post will be fetched from `https://react-tweet.vercel.app/api/tweet/:id`, which is CORS friendly.

We highly recommend adding your own API route to fetch the post in production (as we cannot guarantee our IP will not get limited). You can do it by using the `apiUrl` prop:

```tsx
<Post apiUrl={id && `/api/tweet/${id}`} />
```

> Note: `apiUrl` does nothing if the Post is rendered in a server component because it can fetch directly from Twitter's CDN.

Here's a good example of how to setup your own API route:

```ts
import type { VercelRequest, VercelResponse } from "@vercel/node";
import { getTweet } from "react-tweet/api";

const handler = async (req: VercelRequest, res: VercelResponse) => {
  const tweetId = req.query.tweet;

  if (req.method !== "GET" || typeof tweetId !== "string") {
    res.status(400).json({ error: "Bad Request." });
    return;
  }

  try {
    const post = await getTweet(tweetId);
    res.status(tweet ? 200 : 404).json({ data: tweet ?? null });
  } catch (error) {
    console.error(error);
    res.status(400).json({ error: error.message ?? "Bad request." });
  }
};

export default handler;
```

Something similar can be done with Next.js API Routes or Route Handlers.
